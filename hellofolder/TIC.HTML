<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tic‑Tac‑Toe — Smart & Stylish</title>
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --accent:#06b6d4; --muted:#94a3b8; --win:#10b981;
      --glass: rgba(255,255,255,0.03);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      display:flex;align-items:center;justify-content:center;min-height:100vh;background:linear-gradient(180deg,#071021 0%,#081227 100%);color:#e6eef8;padding:24px
    }
    .app{
      width:100%;max-width:900px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:14px;padding:20px;box-shadow:0 6px 30px rgba(2,6,23,0.6);border:1px solid rgba(255,255,255,0.03);
    }
    header{display:flex;gap:16px;align-items:center;justify-content:space-between}
    h1{font-size:20px;margin:0}
    .controls{display:flex;gap:12px;align-items:center}
    select,button{background:var(--glass);border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px 10px;border-radius:8px}
    button{cursor:pointer;color:#e6eef8}
    .board-wrap{display:flex;gap:20px;margin-top:18px;flex-wrap:wrap}
    .board{width:360px;min-width:260px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));padding:18px;border-radius:12px}
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
    .cell{width:100px;height:100px;min-width:70px;min-height:70px;background:transparent;border-radius:10px;display:flex;align-items:center;justify-content:center;font-size:38px;color:#e6eef8;cursor:pointer;user-select:none;transition:transform .12s ease, background .12s ease}
    .cell:hover{transform:scale(1.03);background:rgba(255,255,255,0.02)}
    .cell.disabled{cursor:default;opacity:0.85}
    .status{padding:12px 10px;margin-top:8px;color:var(--muted)}
    .score{display:flex;gap:12px;flex-direction:column}
    .players{display:flex;gap:6px;align-items:center}
    .pill{background:rgba(255,255,255,0.02);padding:8px 10px;border-radius:999px;border:1px solid rgba(255,255,255,0.02)}
    footer{margin-top:18px;display:flex;justify-content:space-between;align-items:center;color:var(--muted)}
    .highlight{color:var(--accent);font-weight:600}
    .controls small{color:var(--muted);display:block;text-align:right}
    @media (max-width:720px){.board{width:100%}}
    /* winning line animation overlay */
    .line{position:absolute;pointer-events:none}
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Tic Tac Toe game">
    <header>
      <div>
        <h1>Tic‑Tac‑Toe</h1>
        <div class="status" id="status">Choose mode and start the game.</div>
      </div>
      <div class="controls">
        <label for="mode">Mode:</label>
        <select id="mode" aria-label="Game mode">
          <option value="pvp">Player vs Player</option>
          <option value="pvc">Player vs Computer</option>
        </select>
        <label for="ai">AI:</label>
        <select id="ai" aria-label="AI difficulty">
          <option value="easy">Easy</option>
          <option value="medium">Medium</option>
          <option value="hard" selected>Hard (Unbeatable)</option>
        </select>
        <button id="newBtn">New Game</button>
      </div>
    </header>

    <div class="board-wrap">
      <section class="board" aria-label="Game board">
        <div style="position:relative">
          <div id="grid" class="grid" role="grid" aria-label="tic tac toe grid"></div>
          <svg id="lineSvg" class="line" width="360" height="360" style="top:18px;left:18px;position:absolute;" aria-hidden="true"></svg>
        </div>
        <div class="score" style="margin-top:12px">
          <div class="players"><span class="pill">X: <span id="scoreX">0</span></span><span class="pill">O: <span id="scoreO">0</span></span><span class="pill">Ties: <span id="scoreT">0</span></span></div>
        </div>
      </section>

      <aside style="flex:1;min-width:220px">
        <div style="background:rgba(255,255,255,0.02);padding:14px;border-radius:12px">
          <h3 style="margin-top:0">How to play</h3>
          <ol style="color:var(--muted);padding-left:18px">
            <li>Click an empty cell to place your mark (X starts).</li>
            <li>Against computer: choose difficulty. Hard uses Minimax (unbeatable).</li>
            <li>Score persists in local storage.</li>
          </ol>
          <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap">
            <button id="undoBtn">Undo</button>
            <button id="resetScore">Reset Score</button>
          </div>
        </div>
      </aside>
    </div>

    <footer>
      <div>Built with JavaScript • Responsive • Accessible</div>
      <div><small>Hint: Try "Hard" AI — it won't lose.</small></div>
    </footer>
  </div>

<script>
// Tic-Tac-Toe Implementation
const gridEl = document.getElementById('grid');
const statusEl = document.getElementById('status');
const modeSelect = document.getElementById('mode');
const aiSelect = document.getElementById('ai');
const newBtn = document.getElementById('newBtn');
const undoBtn = document.getElementById('undoBtn');
const resetScoreBtn = document.getElementById('resetScore');
const scoreXEl = document.getElementById('scoreX');
const scoreOEl = document.getElementById('scoreO');
const scoreTEl = document.getElementById('scoreT');
const lineSvg = document.getElementById('lineSvg');

let board = Array(9).fill(null); // 0..8
let currentPlayer = 'X';
let gameOver = false;
let history = []; // store moves for undo
let scores = { X:0, O:0, T:0 };

const WIN_COMBOS = [
  [0,1,2],[3,4,5],[6,7,8],
  [0,3,6],[1,4,7],[2,5,8],
  [0,4,8],[2,4,6]
];

function createGrid(){
  gridEl.innerHTML='';
  for(let i=0;i<9;i++){
    const btn = document.createElement('button');
    btn.className='cell';
    btn.setAttribute('data-index',i);
    btn.setAttribute('aria-label',`cell ${i+1}`);
    btn.addEventListener('click', onCellClick);
    gridEl.appendChild(btn);
  }
}

function render(){
  board.forEach((val,i)=>{
    const cell = gridEl.querySelector(`[data-index='${i}']`);
    cell.textContent = val || '';
    cell.classList.toggle('disabled', !!val || gameOver);
  });
  statusEl.textContent = gameOver ? statusEl.textContent : `${currentPlayer}'s turn`;
}

function onCellClick(e){
  const idx = Number(e.currentTarget.dataset.index);
  if(gameOver || board[idx]) return;
  makeMove(idx, currentPlayer);
  if(modeSelect.value === 'pvc' && !gameOver){
    // computer move
    const ai = aiSelect.value;
    setTimeout(()=> aiMove(ai), 250);
  }
}

function makeMove(idx, player){
  board[idx] = player;
  history.push({idx, player});
  checkResult();
  currentPlayer = (player === 'X') ? 'O' : 'X';
  render();
}

function checkResult(){
  // check win
  for(const combo of WIN_COMBOS){
    const [a,b,c] = combo;
    if(board[a] && board[a] === board[b] && board[a] === board[c]){
      gameOver = true;
      statusEl.textContent = `${board[a]} wins!`;
      highlightWin(combo);
      scores[board[a]] +=1; updateScores();
      saveScores();
      return;
    }
  }
  if(board.every(Boolean)){
    gameOver = true;
    statusEl.textContent = `It's a tie!`;
    scores.T +=1; updateScores(); saveScores();
  }
}

function highlightWin(combo){
  // draw line between centers
  const size = 360 - 36; // svg size same as board inner
  const cellSize = (size - 16) / 3; // approximate
  const centers = combo.map(i => {
    const row = Math.floor(i/3), col = i%3;
    const x = col * (cellSize + 8) + cellSize/2 + 8;
    const y = row * (cellSize + 8) + cellSize/2 + 8;
    return {x,y};
  });
  const [p1, p2] = [centers[0], centers[2]];
  lineSvg.innerHTML = `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="${getComputedStyle(document.documentElement).getPropertyValue('--win') || '#10b981'}" stroke-width="10" stroke-linecap="round" opacity="0.95"></line>`;
}

function resetBoard(first='X'){
  board = Array(9).fill(null); currentPlayer = first; gameOver = false; history = []; lineSvg.innerHTML = '';
  statusEl.textContent = `${currentPlayer}'s turn`;
  render();
}

function newGame(){
  const starter = (Math.random() < 0.5) ? 'X' : 'O';
  resetBoard(starter);
}

function updateScores(){
  scoreXEl.textContent = scores.X;
  scoreOEl.textContent = scores.O;
  scoreTEl.textContent = scores.T;
}

function saveScores(){
  try{ localStorage.setItem('tictactoe_scores', JSON.stringify(scores)); }catch(e){}
}
function loadScores(){
  try{ const s = JSON.parse(localStorage.getItem('tictactoe_scores')); if(s) scores = s; }catch(e){}
}

// Undo last move (both players if pvc)
function undo(){
  if(history.length===0 || gameOver) return;
  const last = history.pop();
  board[last.idx] = null;
  currentPlayer = last.player;
  // if pvc and last was player's move and previous was ai, undo both
  if(modeSelect.value === 'pvc' && history.length>0){
    const prev = history[history.length-1];
    if(prev.player !== currentPlayer){
      const rem = history.pop(); board[rem.idx]=null; currentPlayer = rem.player;
    }
  }
  gameOver = false; statusEl.textContent = `${currentPlayer}'s turn`; lineSvg.innerHTML = '';
  render();
}

// AI Move
function aiMove(difficulty){
  if(gameOver) return;
  let idx;
  if(difficulty === 'easy'){
    const empties = board.map((v,i)=>v?null:i).filter(v=>v!==null);
    idx = empties[Math.floor(Math.random()*empties.length)];
  } else if(difficulty === 'medium'){
    // try to win/block, else random
    idx = findWinningMove('O') ?? findWinningMove('X') ?? (board.map((v,i)=>v?null:i).filter(v=>v!==null))[0];
  } else {
    idx = minimaxMove(board, 'O').index;
  }
  if(idx!==undefined) makeMove(idx, 'O');
}

function findWinningMove(player){
  for(let i=0;i<9;i++){
    if(!board[i]){
      board[i]=player;
      const win = WIN_COMBOS.some(c=>board[c[0]] && board[c[0]]===board[c[1]] && board[c[1]]===board[c[2]]);
      board[i]=null;
      if(win) return i;
    }
  }
  return null;
}

// Minimax implementation for unbeatable AI
function minimaxMove(newBoard, player){
  // deep copy
  const avail = newBoard.map((v,i)=>v?null:i).filter(v=>v!==null);
  // check for terminal states
  const winner = getWinner(newBoard);
  if(winner==='X') return {score:-10};
  if(winner==='O') return {score:10};
  if(avail.length===0) return {score:0};

  const moves = [];
  for(const i of avail){
    const move = {};
    move.index = i;
    newBoard[i] = player;
    if(player === 'O'){
      const result = minimaxMove(newBoard, 'X');
      move.score = result.score;
    } else {
      const result = minimaxMove(newBoard, 'O');
      move.score = result.score;
    }
    newBoard[i] = null;
    moves.push(move);
  }
  let bestMove;
  if(player === 'O'){
    let bestScore = -Infinity;
    for(const m of moves){ if(m.score > bestScore){ bestScore = m.score; bestMove = m; } }
  } else {
    let bestScore = Infinity;
    for(const m of moves){ if(m.score < bestScore){ bestScore = m.score; bestMove = m; } }
  }
  return bestMove;
}

function getWinner(bd){
  for(const c of WIN_COMBOS){
    const [a,b,cx] = c;
    if(bd[a] && bd[a] === bd[b] && bd[a] === bd[cx]) return bd[a];
  }
  if(bd.every(Boolean)) return 'T';
  return null;
}

// Event listeners
newBtn.addEventListener('click', newGame);
undoBtn.addEventListener('click', undo);
resetScoreBtn.addEventListener('click', ()=>{ scores = {X:0,O:0,T:0}; updateScores(); saveScores(); });
modeSelect.addEventListener('change', ()=>{ resetBoard('X'); });
aiSelect.addEventListener('change', ()=>{});

// init
createGrid(); loadScores(); updateScores(); newGame(); render();

</script>
</body>
</html>